import matplotlib.pyplot as plt
from matplotlib.collections import LineCollection
from mpl_toolkits.mplot3d.art3d import Line3DCollection
from mpl_toolkits.mplot3d import Axes3D
import numpy as np
import torch

def identify_axes(ax_dict, fontsize=48):
    kw = dict(ha="center", va="center", fontsize=fontsize, color="darkgrey")
    for k, ax in ax_dict.items():
        ax.text(0.5, 0.5, k, transform=ax.transAxes, **kw)

def gca3D(**kwargs):
    fig = plt.figure(figsize=(4,4), **kwargs)
    return Axes3D(fig)

def plt_ffd(ffd, interval=1):
    fig = plt.figure(figsize=(4, 4))
    ax = Axes3D(fig)
    if isinstance(interval, int):
        sl = np.s_[::interval, ::interval, ::interval]
    else:
        sl = interval
    intrv = lambda x:x.reshape(*ffd.n_control_points, 3)[sl].reshape(-1,3)
    ax.scatter(*intrv(ffd.control_points(False)).T, s=10, c='blue')
    ax.scatter(*intrv(ffd.control_points()).T, s=5, c='red')
    # plt_grid3d(ffd.control_points(False), ax, colors='blue')
    plt_grid3d(intrv(ffd.control_points()), ax, colors='red', linewidths=0.5)
    plt.show()

def plt_grid3d(pts, ax, **kwargs):
    l = np.round(len(pts)**(1/3)).astype(int)
    x, y, z = pts.T.reshape(-1, l, l, l)
    grid1 = np.stack((x,y,z), axis=-1)
    ax.add_collection3d(Line3DCollection(grid1.reshape(-1, l, 3), **kwargs))
    ax.add_collection3d(Line3DCollection(grid1.transpose(0,2,1,3).reshape(-1, l, 3),  **kwargs))
    ax.add_collection3d(Line3DCollection(grid1.transpose(1,2,0,3).reshape(-1, l, 3),  **kwargs))

def plot_grid(ax, flow, factor=10):
    """
    Plot the grid generated by a flow on the given axis.

    Parameters:
    ax (matplotlib.axes.Axes): The axis to plot the grid on.
    flow (numpy.ndarray, H, W, C): A 2D array representing the flow.
    factor (int, optional): Scale factor to amplify the displacement of the flow. Default is 10.

    Returns:
    None
    """
    grid = factor * flow
    lin_range = np.arange(0, grid.shape[0], 1)
    x, y = np.meshgrid(lin_range, lin_range, indexing='ij')
    x = x + grid[..., 0]
    y = y + grid[..., 1]
    y = y

    segs1 = np.stack((x, y), axis=2)
    segs2 = segs1.transpose(1, 0, 2)
    ax.add_collection(LineCollection(segs1, color='black', linewidths=0.8))
    ax.add_collection(LineCollection(segs2, color='black', linewidths=0.8))
    ax.autoscale()

def plt_close():
    plt.close()

def plot_landmarks(img, landmarks, fig=None, ax=None, save_path=None, every_n = 3, color='red',size=10, proj_landmarks=None, proj_color='green', save_each=False):
    """
    Plot landmarks on the input image.

    Parameters:
    - img (torch.tensor): Input image tensor.
    - landmarks (torch.tensor): Input landmarks tensor.
    - fig (matplotlib.figure.Figure, optional): Figure object to be used for plotting. Default is None.
    - ax (matplotlib.axes._subplots.AxesSubplot, optional): Axes object to be used for plotting. Default is None.
    - save_path (str, optional): Path to save the plot. Default is None.
    - every_n (int, optional): Plot every n-th slice of the input image. Default is 3.
    - color (str, optional): Color of the landmarks. Default is 'red'.
    - size (int, optional): Size of the landmarks in the plot. Default is 10.

    Returns:
    - fig (matplotlib.figure.Figure): Figure object used for plotting.
    - axes (matplotlib.axes._subplots.AxesSubplot): Axes object used for plotting.
    """
    if isinstance(img, torch.Tensor):
        img = img.cpu().numpy()
        landmarks = landmarks.cpu().numpy()
    if fig is None:
        fig = plt.figure(figsize=(10, 10))
    if ax is None:
        axes = fig.subplots(len(landmarks), 5)
    else: axes = ax


    dist_lmk = None
    if proj_landmarks is not None:
        if isinstance(proj_landmarks, torch.Tensor):
            proj_landmarks = proj_landmarks.cpu().numpy()
        for i in range(landmarks.shape[0]):
            axes[i,2].scatter(proj_landmarks[i, 2], proj_landmarks[i, 1], s=size, c=proj_color, marker='x')
            # axes[i,4].scatter(proj_landmarks[i, 2], proj_landmarks[i, 0], s=size, c=proj_color, marker='x')
        dist_lmk = np.sqrt(np.sum((landmarks[:, 1:]-proj_landmarks[:, 1:])**2, axis=1))

    # calculate idx to be visualized
    for i in range(landmarks.shape[0]):
        x0 = landmarks[i, 0]
        axes[i,2].scatter(landmarks[i, 2], landmarks[i, 1], s=size, c=color, marker='x')
        if ax is None:
            axes[i,0].imshow(img[int(x0)-2*every_n, ...], cmap='gray')
            # caption
            axes[i,0].set_title(f'{int(x0)-2*every_n}')
            axes[i,1].imshow(img[int(x0)-every_n, ...], cmap='gray')
            axes[i,1].set_title(f'{int(x0)-every_n}')
            axes[i,2].imshow(img[int(x0), ...], cmap='gray')
            if dist_lmk is not None:
                axes[i,2].set_title(f'{int(x0)}, ({landmarks[i, 0]}, {landmarks[i, 1]}, {landmarks[i, 2]}), {dist_lmk[i]:.2f}')
            else: axes[i,2].set_title(f'{int(x0)}, ({landmarks[i, 0]}, {landmarks[i, 1]}, {landmarks[i, 2]})')
            axes[i,3].imshow(img[int(x0)+every_n, ...], cmap='gray')
            axes[i,3].set_title(f'{int(x0)+every_n}')
            axes[i,4].imshow(img[int(x0)+2*every_n, ...], cmap='gray')
            axes[i,4].set_title(f'{int(x0)+2*every_n}')
    # tight layout and no axis
    fig.tight_layout()
    for ax in fig.get_axes():
        ax.axis('off')
    if save_path is not None:
        plt.savefig(save_path)
    if save_each:
        from pathlib import Path as pa
        save_dir = pa(save_path).parent / pa(save_path).stem
        save_dir.mkdir(exist_ok=True)
        for i in range(landmarks.shape[0]):
            # save img in the middle
            # Save just the portion _inside_ the second axis's boundaries
            extent = axes[i,2].get_window_extent().transformed(fig.dpi_scale_trans.inverted())
            fig.savefig(save_dir / f'{i}.png', dpi=300,
                        bbox_inches=extent)
    return fig, axes

def plot_to_PIL():
    """
    Convert a matplotlib plot into a PIL image."""
    from io import BytesIO
    from PIL import Image
    # convert the plot into a bytes-like object
    buf = BytesIO()
    plt.savefig(buf, format="png")
    buf.seek(0)
    # open the image using PIL
    im = Image.open(buf)
    return im


if __name__=='__main__':
    #%%
    import monai
    file = '/mnt/sdc/lits/train/volume-102.nii'
    fdir = '/mnt/sdc/lits/train'
    # glob nii
    import glob
    nii_files = sorted(glob.glob(f'{fdir}/volum*.nii'), key=lambda x: int(x.split('-')[-1].split('.')[0]))
    print(nii_files)
    #%%
    from monai.transforms import (
        Compose, LoadImage
    )
    print(nii_files[128])
    LoadImage()(nii_files[128])
    #%%
    img, meta = LoadImage()(nii_files[75])
    meta['space']

import torch


def rgb2hsl_torch(rgb: torch.Tensor) -> torch.Tensor:
    cmax, cmax_idx = torch.max(rgb, dim=1, keepdim=True)
    cmin = torch.min(rgb, dim=1, keepdim=True)[0]
    delta = cmax - cmin
    hsl_h = torch.empty_like(rgb[:, 0:1, :, :])
    cmax_idx[delta == 0] = 3
    hsl_h[cmax_idx == 0] = (((rgb[:, 1:2] - rgb[:, 2:3]) / delta) % 6)[cmax_idx == 0]
    hsl_h[cmax_idx == 1] = (((rgb[:, 2:3] - rgb[:, 0:1]) / delta) + 2)[cmax_idx == 1]
    hsl_h[cmax_idx == 2] = (((rgb[:, 0:1] - rgb[:, 1:2]) / delta) + 4)[cmax_idx == 2]
    hsl_h[cmax_idx == 3] = 0.
    hsl_h /= 6.

    hsl_l = (cmax + cmin) / 2.
    hsl_s = torch.empty_like(hsl_h)
    hsl_s[hsl_l == 0] = 0
    hsl_s[hsl_l == 1] = 0
    hsl_l_ma = torch.bitwise_and(hsl_l > 0, hsl_l < 1)
    hsl_l_s0_5 = torch.bitwise_and(hsl_l_ma, hsl_l <= 0.5)
    hsl_l_l0_5 = torch.bitwise_and(hsl_l_ma, hsl_l > 0.5)
    hsl_s[hsl_l_s0_5] = ((cmax - cmin) / (hsl_l * 2.))[hsl_l_s0_5]
    hsl_s[hsl_l_l0_5] = ((cmax - cmin) / (- hsl_l * 2. + 2.))[hsl_l_l0_5]
    return torch.cat([hsl_h, hsl_s, hsl_l], dim=1)


def rgb2hsv_torch(rgb: torch.Tensor) -> torch.Tensor:
    cmax, cmax_idx = torch.max(rgb, dim=1, keepdim=True)
    cmin = torch.min(rgb, dim=1, keepdim=True)[0]
    delta = cmax - cmin
    hsv_h = torch.empty_like(rgb[:, 0:1, :, :])
    cmax_idx[delta == 0] = 3
    hsv_h[cmax_idx == 0] = (((rgb[:, 1:2] - rgb[:, 2:3]) / delta) % 6)[cmax_idx == 0]
    hsv_h[cmax_idx == 1] = (((rgb[:, 2:3] - rgb[:, 0:1]) / delta) + 2)[cmax_idx == 1]
    hsv_h[cmax_idx == 2] = (((rgb[:, 0:1] - rgb[:, 1:2]) / delta) + 4)[cmax_idx == 2]
    hsv_h[cmax_idx == 3] = 0.
    hsv_h /= 6.
    hsv_s = torch.where(cmax == 0, torch.tensor(0.).type_as(rgb), delta / cmax)
    hsv_v = cmax
    return torch.cat([hsv_h, hsv_s, hsv_v], dim=1)

def hsv2rgb(hsl: torch.Tensor) -> torch.Tensor:
    hsl = hsl[None]
    return hsv2rgb_torch(hsl)[0]
def hsv2rgb_torch(hsv: torch.Tensor) -> torch.Tensor:
    hsv_h, hsv_s, hsv_l = hsv[:, 0:1], hsv[:, 1:2], hsv[:, 2:3]
    _c = hsv_l * hsv_s
    _x = _c * (- torch.abs(hsv_h * 6. % 2. - 1) + 1.)
    _m = hsv_l - _c
    _o = torch.zeros_like(_c)
    idx = (hsv_h * 6.).type(torch.uint8)
    idx = (idx % 6).expand(-1, 3, -1, -1)
    rgb = torch.empty_like(hsv)
    rgb[idx == 0] = torch.cat([_c, _x, _o], dim=1)[idx == 0]
    rgb[idx == 1] = torch.cat([_x, _c, _o], dim=1)[idx == 1]
    rgb[idx == 2] = torch.cat([_o, _c, _x], dim=1)[idx == 2]
    rgb[idx == 3] = torch.cat([_o, _x, _c], dim=1)[idx == 3]
    rgb[idx == 4] = torch.cat([_x, _o, _c], dim=1)[idx == 4]
    rgb[idx == 5] = torch.cat([_c, _o, _x], dim=1)[idx == 5]
    rgb += _m
    return rgb


def hsl2rgb_torch(hsl: torch.Tensor) -> torch.Tensor:
    hsl_h, hsl_s, hsl_l = hsl[:, 0:1], hsl[:, 1:2], hsl[:, 2:3]
    _c = (-torch.abs(hsl_l * 2. - 1.) + 1) * hsl_s
    _x = _c * (-torch.abs(hsl_h * 6. % 2. - 1) + 1.)
    _m = hsl_l - _c / 2.
    idx = (hsl_h * 6.).type(torch.uint8)
    idx = (idx % 6).expand(-1, 3, -1, -1)
    rgb = torch.empty_like(hsl)
    _o = torch.zeros_like(_c)
    rgb[idx == 0] = torch.cat([_c, _x, _o], dim=1)[idx == 0]
    rgb[idx == 1] = torch.cat([_x, _c, _o], dim=1)[idx == 1]
    rgb[idx == 2] = torch.cat([_o, _c, _x], dim=1)[idx == 2]
    rgb[idx == 3] = torch.cat([_o, _x, _c], dim=1)[idx == 3]
    rgb[idx == 4] = torch.cat([_x, _o, _c], dim=1)[idx == 4]
    rgb[idx == 5] = torch.cat([_c, _o, _x], dim=1)[idx == 5]
    rgb += _m
    return rgb

if False:
#%%
    import matplotlib.pyplot as plt
    # import seaborn as sns
    import torch
    import numpy as np

    dice_x = [0.01, 0.05, 0.1, 0.15, 0.2, 1]
    stsr_y = [1.39**2, 1.19**2, 1.15**2, 1.13**2, 1.13**2, 1.205]

    ours = (0.17, 1.26) # triangle
    whole = (0.05, 1.64) # x

    # liver_dice_y = [0.8960, 0.9041, 0.9078, 0.9066, 0.9120, 0.911]
    # ours_dice = (0.17, 0.908)
    # whole_dice = (0.05, 0.903)
    plt.figure(figsize=(6,4))
    plt.grid(linestyle='--', linewidth=0.5, alpha=0.5)
    ax = plt.gca()
    # ticks with 0.05 interval, but show labels with 0.1 interval
    plt.xticks(np.arange(0, 1.1, 0.05), [i if i%0.1==0 else ''
                                        for i in np.arange(0, 1.1, 0.05)])

    import matplotlib.ticker as ticker

    # enlarge size of words

    plt.xlabel('Dice Score of Tumor Mask', fontsize=15)
    plt.ylabel('Test STSR', fontsize=15)

    plt.plot(dice_x, stsr_y, color='r', marker='s', markevery=1, mew=0.25, linewidth=2)
    legends = ['Noisy GT']
    # for i_x, i_y in zip(dice_x, stsr_y):
    #     if i_x>=0.15 and i_x<=0.2: continue
    #     plt.text(i_x, i_y, '({}, {:.1f})'.format(i_x, i_y))
    for i_x, i_y in [ours,]:
        plt.text(i_x-0.05, i_y-0.05, '({}, {:.1f})'.format(i_x, i_y))
    for i_x, i_y in [whole,]:
        plt.text(i_x+0.01, i_y-0.01, '({}, {:.1f})'.format(i_x, i_y))


    # show the coordinate
    plt.scatter(ours[0], ours[1], marker='D', )
    legends += ['Volume Preserving for Tumor']
    plt.scatter(whole[0], whole[1], marker='x')
    legends += ['Volume Preserving for Organ']
    # plt.plot(dice_x, liver_dice_y, color='b', marker='o', markevery=1, mew=0.25, linewidth=2)

    # Format the x-tick labels to show every other tick with 0.1 using FormatStrFormatter
    # ax.xaxis.set_major_formatter(ticker.FormatStrFormatter('%0.1f'))

    plt.legend(legends, fontsize=15, loc='upper right')
    plt.tight_layout()
    plt.savefig("fig6.pdf")

    # plt.show()

    #%%
    # Import Library

    import numpy as np
    import matplotlib.pyplot as plt

    # Define Data

    x = np.arange(0, 15, 0.2)
    data_1 = np.tan(x)
    data_2 = np.exp(x)

    # Create Plot

    fig, ax1 = plt.subplots()

    ax1.set_xlabel('X-axis')
    ax1.set_ylabel('Y1-axis', color = 'black')
    plot_1 = ax1.plot(x, data_1, color = 'black')
    ax1.tick_params(axis ='y', labelcolor = 'black')

    # Adding Twin Axes

    ax2 = ax1.twinx()

    ax2.set_ylabel('Y2-axis', color = 'green')
    plot_2 = ax2.plot(x, data_2, color = 'green')
    ax2.tick_params(axis ='y', labelcolor = 'green')

    # Set same axes sacles

    a,b = -200, 200
    ax1.set_ylim(a,b)
    ax2.set_ylim(a,b)

    # Show plot

    plt.show()

    #%% write metrics plot
